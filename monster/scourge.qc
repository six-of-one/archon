/*
==============================================================================

SCOURGE

==============================================================================
*/

$origin 0 0 23
$base scorbase
$skin skin

/// scor2c.mdl
// scourge - 2 of 2x nailguns
/// scor2e.mdl
// super scourge - 2 of 2x super nailguns

$frame stand1 stand2 stand3 stand4 stand5 stand6
$frame stand7 stand8 stand9 stand10 stand11 stand12

$frame walk1 walk2 walk3 walk4 walk5 walk6

$frame shoot1 shoot2

/// not used for scor2c, shots for scor2e
// all tri shoot - fire flares from 3 ports of nail guns
//							 - until we decided to remove the firing flares

$frame shootri1 shootri2 shootri3 shootri4

$frame sting1 sting2 sting3 sting4 sting5 sting6
$frame sting7 sting8 sting9 sting10 sting11

$frame death1 death2 death3 death4 death5

$frame pain1 pain2 pain3 pain4 pain5

/// end 1st scourge

// 45 - cnt of frames for rf6



/// scor2c.mdl
// mega scourge - 4 of 3x nailguns
/// scor2e.mdl --- NOT coded in
// large mega scourge - 4 of 3x nailguns

$frame msstand1 msstand2 msstand3 msstand4 msstand5 msstand6
$frame msstand7 msstand8 msstand9 msstand10 msstand11 msstand12

$frame mswalk1 mswalk2 mswalk3 mswalk4 mswalk5 mswalk6

$frame msshoot1 msshoot2

// all tri shoot - fire flares from 3 ports of nail guns
$frame msshootri1 msshootri2 msshootri3 msshootri4

$frame mssting1 mssting2 mssting3 mssting4 mssting5 mssting6
$frame mssting7 mssting8 mssting9 mssting10 mssting11

$frame msdeath1 msdeath2 msdeath3 msdeath4 msdeath5

$frame mspain1 mspain2 mspain3 mspain4 mspain5

/// end 2nd scourge



/// scor2c.mdl --- NOT coded in
// scourge - 6 of 3x nailguns
/// scor2e.mdl
// super scourge - 6 of 3x super nailguns

$frame sxstand1 sxstand2 sxstand3 sxstand4 sxstand5 sxstand6
$frame sxstand7 sxstand8 sxstand9 sxstand10 sxstand11 sxstand12

$frame sxwalk1 sxwalk2 sxwalk3 sxwalk4 sxwalk5 sxwalk6

$frame sxshoot1 sxshoot2

$frame sxshootri1 sxshootri2 sxshootri3 sxshootri4

$frame sxsting1 sxsting2 sxsting3 sxsting4 sxsting5 sxsting6
$frame sxsting7 sxsting8 sxsting9 sxsting10 sxsting11

$frame sxdeath1 sxdeath2 sxdeath3 sxdeath4 sxdeath5

$frame sxpain1 sxpain2 sxpain3 sxpain4 sxpain5

/// end 3rd scourge



/// scor2c.mdl
// mini scourge - 1 nailgun
/// scor2e.mdl
// super XTRA MAD scourge - 6 of 3x super MAD nailguns

$frame memstand1 memstand2 memstand3 memstand4 memstand5 memstand6
$frame memstand7 memstand8 memstand9 memstand10 memstand11 memstand12

$frame memwalk1 memwalk2 memwalk3 memwalk4 memwalk5 memwalk6

$frame memshoot1 memshoot2

$frame memhootri1 memhootri2 memhootri3 memhootri4

$frame memsting1 memsting2 memsting3 memsting4 memsting5 memsting6
$frame memsting7 memsting8 memsting9 memsting10 memsting11

$frame memdeath1 memdeath2 memdeath3 memdeath4 memdeath5

$frame mempain1 mempain2 mempain3 mempain4 mempain5

/// end 4th scourge



/// scor2c.mdl
// baby scourge - 0 nailguns
/// scor2e.mdl
// ULTRA scourge - 6 of 6x ULTRA guns

// uber scourge - 6x size of regular - 2x size of super 6
// ultimate bawse scourge - should only ever be ONE of these
// this is what happens when the super 6 scourge eats a SUPER quad damage


$frame bultstand1 bultstand2 bultstand3 bultstand4 bultstand5 bultstand6
$frame bultstand7 bultstand8 bultstand9 bultstand10 bultstand11 bultstand12

$frame bultwalk1 bultwalk2 bultwalk3 bultwalk4 bultwalk5 bultwalk6

$frame bultshoot1 bultshoot2

$frame bulthootri1 bulthootri2 bulthootri3 bulthootri4

$frame bultsting1 bultsting2 bultsting3 bultsting4 bultsting5 bultsting6
$frame bultsting7 bultsting8 bultsting9 bultsting10 bultsting11

$frame bultdeath1 bultdeath2 bultdeath3 bultdeath4 bultdeath5

$frame bultpain1 bultpain2 bultpain3 bultpain4 bultpain5

/// end 5th scourge



/// scourge specials

// integrated severed head - uses skin 3

/// scor2c.mdl
// std, mini, baby
/// scor2e.mdl
// super, XMAD, ULTRA

$frame head1 head2 head3

/// scor2c.mdl
// regular size pod
/// scor2e.mdl
// super size pod

// seed pod - pod6 in scor2c is = pod5

$frame pod1 pod2 pod3 pod4 pod5 pod6

/// scor2c.mdl
// regular 2 gun to mega 4 gun
/// scor2e.mdl -- NOT coded in
// super 2 gun to large mega 4 gun

// expand gun ports from 2 to 4

$frame tgexpand1 tgexpand2 tgexpand3 tgexpand4 tgexpand5 tgexpand6

/// scor2c.mdl -- NOT coded in
// regular 2 gun to 6 gun
/// scor2e.mdl
// super 2 gun to super 6 gun

// expand gun ports from 2 to 6

$frame sxgexpand1 sxgexpand2 sxgexpand3 sxgexpand4 sxgexpand5 sxgexpand6

/// scor2e.mdl
// regular to super 2 gun

// grow from reg scourge to 2 gun super scourge
$frame scgrow1 scgrow2 scgrow3 scgrow4 scgrow5 scgrow6

/// scor2e.mdl
// mega to super 6 gun

// grow from mega scourge to 6 gun super scourge
$frame smgrow1 smgrow2 smgrow3 smgrow4 smgrow5 smgrow6 smgrow7

/// scor2e.mdl
// super 6 gun to super XTRA MAD 6 gun

// grow from super scourge to extra mad super scourge
$frame sxgrow1 sxgrow2 sxgrow3 sxgrow4 sxgrow5 sxgrow6
$frame sxgrow7 sxgrow8 sxgrow9 sxgrow10
// 2 extra unused frames to balance offsets
$frame sxgrow11 sxgrow12

/// end scourge specials



// enhanced constants & control vars

float SC_MAX; // max scourge on a level
float sc_stop_grow; // when to stop growing baby & mini
float sc_count; // total number on map - also used to slow growth cycle
#define sc_radt_mult 2 // multiplier for sc_count add in to rad_time - more scourge slows down growth

// no bits 2 - 128				 regular scourge - 2 nail 2x pods
#define SC_MEGA	2 // mega scourge - 4 nail 3x pods
#define SC_SUPER	4 // super scourge - 2 nail 2x pods
#define SC_SUPER6	8 // super scourge - 6 nail 3x pods
#define SC_SUPER6_EXTRA_MAD	16 // super scourge - 6 nail 3x pods, extra mad
#define SC_MINI	32 // mini scourge
#define SC_BABY	64 // baby scourge
#define SC_ULTRA 512 // Ultra scourge - buku boss fight
// unused
// poison - 1024
// death - 2048
// wraith - 4096

//#define SC_STUNT 8192 // this scourge will not evolve, if enhanced is on

#define SC_WEE 96 // wee ones
#define SC_SUPERS 28 // all super scourges
#define SC_SUPER6S 24 // both super 6 scourges
#define SC_FRAMED 1022 //238; all of the aboved that run with frame offsets in xscourge
#define SC_HEAL 30 // for super & mega self heals
#define SC_NEVOL 0 // set to 1 to stop evolutions - 7.28.14 - map spawned scourge can be blocked with spawnflags & 8192 - stunt growth

/// issue: 256 - 2048 are engine excludes for some difficulty - would cause problems with map loaded scourge

// harder skinned - "hot" scourge
#define SC_CTHON	128 // cthon scourge - can still use super flags
#define SC_LAVA	256 // lava scourge - slightly less than cthon scourge, also not implemented

#define SC_HOT 384 // mask off hot flags
#define SC_TYPE 9214 //1022; validate scourge type bits - 1022 + 8192 = 9214

#define sc_rnd 0.8 // total chance for a better random scourge
#define sc_imp 0.2 // total chance for a better map scourge
#define sc_cth 0.45 // if improving on load, chance we get a cthon scrourge

void()   xscourge_suxpand1;
void()   xscourge_mgrow1;
void()   xscourge_msxpand1;

#define sc_super_spike 24 // damage done by super spikes
#define sc_track 0.4 // chance a super /mega shot will turn on trackers - turned off in walk / run
#define sc_track_dmg 21 // damage done by tracker
#define sc_laser 0.2 // chance a super /mega shot will turn on bounce lasers - turned off in walk / run
#define sc_laser_dmg 27 // damage done by laser
#define SC_FIRE_TRACK -62346 // fire tracking spikes
#define SC_FIRE_TRIPLE -63566 // fire triple nail guns per pod
#define SC_FIRE_LASER -63789 // fire triple refl lasers per pod

// pod constants
#define SC_POD_TIME 110 // idle time till scourge can make a pod
#define SC_POD2_TIME 300 // idle time till scourge can make a 2nd pod
#define sc_pod_chn 0.24 // chance a scourge can make a pod when time is up
#define sc_dead_pod 0.4 // chance a dead scourge will pod
#define sc_pod_cnt 4 // base cnt babys from a pod
#define sc_smpod_rnd 4
#define sc_mgpod_rnd 8 // rnd babys mega pod
#define sc_sppod_rnd 16 // rnd babys super pod
#define sc_empod_rnd 24 // rnd babys extra mad super pod
#define sc_sppod_min 4 // minis from super pod + smpod_rnd

#define sc_emheal 100 // how much a super scourge thats extra mad could heal in a pain frame
#define sc_emheal_chn 0.4 // chance to heal

#define sc_baby_vol 0.5
#define sc_mini_vol 0.7

// skin codes
#define SKN_CTHON 1
#define SKN_LAVA 2
#define SKN_HEAD 3
#define SKN_BLU 4

// spike.mdl, nail.mdl frames
#define SC_SPIKE_LG 9
#define SC_SPIKE_MIN 8

//============================================================================
// mega & super - run frames
// make an adjustment so regular frame macros can run scourges beyond the regular set

void() sc_run_frames =
{
//	if (!self.spawnflags & SC_SUPERS)
//	if (!self.spawnflags & SC_FRAMED) return; // not baby, mini, mega or super - cant run frames --- FIX or remove
// can all run frames now - expanded set

	if (self.walkframe)
	if (self.frame < self.walkframe)
		self.frame = self.frame + self.walkframe;
};

// scourges above regular have a chance to self heal

void(float per) xscourge_heal =
{
	local float hl, pr;

	if (self.max_health <= 0) self.max_health = 909;
	if (self.health >= self.max_health) return;

	chance = sc_emheal_chn;
	if (!self.spawnflags & SC_SUPERS)
	{
		if (!self.spawnflags & SC_MEGA) return; // not mega or super - cant heal
		chance = sc_emheal_chn * 0.5;
	}

	if (random() > chance) return;

	pr = per;
	if ((per <= 0) || (per > 1)) pr = 1;

	hl = self.spawnflags & SC_HEAL;




//local float h2; // TEST
//h2 = self.health;



	self.health = self.health + ceil(pr * hl * random());


/* TEST
if (1)
{
																								bprint(" *** scourge self heal: ");
																								bprint(ftos(self.health - h2));
																								bprint(" - hl: ");
																								bprint(ftos(hl));
																								bprint(" - pr: ");
																								bprint(ftos(pr));
																								bprint("\n");
}
*/


	if (self.health > self.max_health) self.health = self.max_health;
};

// remove stuck pod scourge

#define AS_SPLINCH -666 // so a splinched monster can be gibbed when th_die is called

// something got permanently stuck and needs to die

void() splinch_die =
{	
	if ((!self.owner.flags & FL_MONSTER) || (sc_count < 7))
	{
		remove(self);
		return;
	}



if (1)
{
	bprint("*** warning - splinch die for: ");
	bprint(self.owner.classname);
	bprint(" - ");
	bprint(self.owner.netname);
	bprint("\n");
}



	self.owner.state = AS_SPLINCH;
	T_Damage (self.owner,world,world,self.owner.health * 2); 
	remove(self);
};

void() splinch_test =
{
	if (self.event != "dyn_monster") return;
//	if (self.class_select != "class_monster") return; // when we move to generic ai, incase other ents use monster ai

	if (self.oldorigin != self.origin)
		self.oldorigin = self.origin;
	else if (sc_count > 6)
		if (random() < 0.33)
	{
		if (!self.wait)
//		if (self.state != AS_SPLINCH)
		{
			self.wait = time + 120;
			self.state = AS_SPLINCH;
		}

		if (self.state == AS_SPLINCH)
		if (self.wait < time)
		{
			if (random() < 0.66)
			if (sc_count < 32)
			{
				newmis = spawn ();
				newmis.owner = self;
				newmis.think = phone_teleport;
				newmis.nextthink = (time + 0.2);
				self.state = self.wait = 0;
				return;
			}
			chaos_spawn(MOVETYPE_NONE, SOLID_NOT, 0, 0, v0, v0, v0, v0, v0, "splinch_kill", null_string, SUB_Null, 1, splinch_die, SUB_Null, self, world);
			self.wait = MAXFL; // only make 1 per monster
		}
	}
};

//============================================================================

// pods

void(entity o, vector v, float flgs) spawnmonster_scourge =
{
	local entity e;

	newmis = e = spawn();
	e.spawnflags = flgs;
	e.class_select = "class_monster"; // so item_call does not itemize him
	e.event = "dyn_monster"; // so noway will clear these when they are out of bounds
	item_call_save(e, "monster_scourge");
	e.owner = o;
	setorigin(e, v);
	e.angles_y = rint(random() * 360);
};

void() pod_born =
{
	local float sflg, r;

	self.cnt = sc_pod_cnt;
	if (self.spawnflags & SC_SUPER6_EXTRA_MAD)
	{
		self.cnt = self.cnt + rint(random() * sc_empod_rnd);
		self.count = sc_sppod_min + rint(random() * sc_smpod_rnd);
	}
	else
	if (self.spawnflags & SC_SUPERS)
		self.cnt = self.cnt + rint(random() * sc_sppod_rnd);
	else
	if (self.spawnflags & SC_MEGA)
		self.cnt = self.cnt + rint(random() * sc_mgpod_rnd);
	else
		self.cnt = self.cnt + rint(random() * sc_smpod_rnd);

	sflg = self.spawnflags & SC_HOT;
	if (sc_count < SC_MAX)
	while (self.cnt > 0)
	{
		spawnmonster_scourge(self.owner, self.origin + '0 0 16', sflg | SC_BABY);
		item_eject(newmis, MED_BOUNCE);
		self.cnt = self.cnt - 1;
	}

	if (sc_count < SC_MAX)
	while (self.count > 0)
	{
		spawnmonster_scourge(self.owner, self.origin + '0 0 16', sflg | SC_MINI);
		item_eject(newmis, MED_BOUNCE);
		self.count = self.count - 1;
	}

// toss some gibs just for looks
	self.lip = 2 + rint(random() * 4);
	self.count = self.lip * 5;
	while (self.lip > 0)
	{
		r = rint(random() * 4.1);
		if (r == 4)
		{
			ThrowGib ("progs/scor2c.mdl", self.count + random() * 25);
			newmis.frame = $bultdeath5;
		}
		else
		{
			ThrowGib ("progs/gib_m.mdl", self.count + random() * 25);
			if (r < 3) newmis.frame = r;
			else newmis.frame = 8;
		}
		self.lip = self.lip - 1;
	}

	sound (self, CHAN_VOICE, self.noise4, 1, ATTN_NORM);

	remove(self);
};

// pod was killed before it could make babys


void() pod_die =
{
	local float r;

	if (self.spawnflags & SC_SUPERS)
		self.cnt = self.cnt + random() * sc_sppod_rnd;
	else
	self.cnt = self.cnt + random() * sc_smpod_rnd;
	self.count = self.cnt * 2;

	while (self.cnt > 0)
	{
		r = floor(random() * 4.4);
		if (r == 4) // dead baby - life is ugly sometimes
		{
			ThrowGib ("progs/scor2c.mdl", self.count + random() * 25);
			newmis.frame = $bultdeath5;
		}
		else
		{
			ThrowGib ("progs/gib_m.mdl", self.count + random() * 25);
			if (r < 3) newmis.frame = r;
			else newmis.frame = 8;
		}
		self.cnt = self.cnt - 1;
	}

	sound (self, CHAN_VOICE, "player/udeath.wav", 1, ATTN_NORM);

	remove(self);
};

// IDEA: twitch pods

void() pod_level1 =
{
	self.think = pod_born;
	self.nextthink = time + SC_POD_TIME + crandom() * 30;
	self.th_die = pod_born;
	self.takedamage = DAMAGE_AIM; // in case it was invulnerable during gestate
};

// pod gestates for a random time (30 -45 rels) after which if killed it will make babys
// if killed during gestate it just throws out gibs and dead babys
// SC_POD_TIME (110) +- 30 rels after gestate, pop will pop and make babys

void(float sc) pod_make =
{
	newmis = spawn();
	newmis.owner = self;
	setmodel(newmis, "progs/scor2c.mdl");
	setsize (newmis, VEC_HULL_MIN, VEC_HULL_MAX);
	newmis.angles_y = rint(random() * 360);
	newmis.health = 150;
	newmis.takedamage = DAMAGE_AIM;
	newmis.netname = "SCPOD";
	newmis.solid = SOLID_SLIDEBOX;
	newmis.movetype = MOVETYPE_TOSS;
	newmis.class_select = "class_monster"; // noway op
	newmis.event = "dyn_monster"; // so noway will clear these when they are out of bounds

	newmis.th_die = pod_die;
	newmis.think = pod_level1;
	newmis.nextthink = time + 30 + random() * 15;
	newmis.frame = $pod1;

// if true, we are making this from a scourge entity
	if (sc)
	{
		setorigin(newmis, self.origin);
		sound (self, CHAN_VOICE, self.noise3, 1, ATTN_NORM);
		if (self.spawnflags & SC_SUPERS) // same kind as scourge
		{
			setsize (newmis, VEC_HULL2_MIN, VEC_HULL2_MAX);
			newmis.frame = $pod3;
			newmis.health = 300;
		}
		newmis.spawnflags = self.spawnflags;
		newmis.skin = self.skin;
		newmis.angles = self.angles;
	}
	if (newmis.spawnflags & SC_CTHON)
		newmis.health = newmis.health * 2;
};

// map spawned pod

/*QUAKED monster_scourge_pod (1 0 0) (-16 -16 -24) (16 16 40) NULL Mega Super Super6 NULL NULL NULL Cthon Lava NULL Poison Death Wraith

"NULL" - not used, ignore

"angle" - set facing angle of pod
"wait" - time until pod pops - default 110 - 185 rels
"dmg" - if TRUE pod will be invulnerable to fire during gestate

Pods will be made for these:
" Mega" - 2 extra 3x nailguns, a bit tougher
"Super" - double size, double bad
"Super6" - double size with 4 extra 3x nailguns, ton tougher
"Cthon" - Cthon scourge - toughest
"Lava" - Lava skin scourge - tougher

not implemented:
"Poison" - has poisoned nails, stinger, green skin
"Death" - death scourge
"Wraith" - wraith scourge
These will make regular pods
*/

void() monster_scourge_pod =
{
	if (self.spawnflags & SC_CTHON)
		self.skin = SKN_CTHON;

	pod_make(TRUE);
	if (self.wait) newmis.nextthink = time + self.wait;
	if (self.dmg) newmis.takedamage = DAMAGE_NO;
	remove(self);
};

// run pods

void() sc_pods =
{
	if (self.lasttime)
	if (self.lasttime < time)
	{
		self.lasttime = time + SC_POD2_TIME;
		if (!self.spawnflags & SC_WEE)
		if (sc_count < SC_MAX)
		if (random() < sc_pod_chn) // make a baby pod
		{
			pod_make(TRUE);
			item_eject(newmis, GEN_BOUNCE);
		}
	}
};

//============================================================================

/*
===========
ScourgeCheckAttack

The player is in view, so decide to move or launch an attack
Returns FALSE if movement should continue
============
*/
float() ScourgeCheckAttack =
{
	local vector	spot1, spot2;
	local entity	targ;
//	local float		enemy_yaw_;

	targ = self.enemy;
// see if any entities are in the way of the shot
	spot1 = self.origin + self.view_ofs;
	spot2 = targ.origin + targ.view_ofs;

	if (vlen(spot1 - spot2) <= 100 )
		{
			if (CanDamage (self.enemy, self))
			{
				self.attack_state = AS_MELEE;
				return TRUE;
				}
		}							
	if (time < self.attack_finished)
		return FALSE;

	if (!enemy_vis)
		return FALSE;


	chance = spot2_z - spot1_z;
	if (chance > 64)
		return FALSE;
	else if (chance < -200)
		return FALSE;

	if (vlen(spot1 - spot2) > 1000)
		return FALSE;

	if (vlen(spot1 - spot2) < 150)
		return FALSE;

	traceline (spot1, spot2, FALSE, self);

	if (trace_inopen && trace_inwater)
		return FALSE;			// sight line crossed contents

	if (trace_ent != targ)
		{
		return FALSE;	// don't have a clear shot
		}

// missile attack
//   if (enemy_range == RANGE_FAR)
//      return FALSE;

	self.attack_state = AS_MISSILE;
	SUB_AttackFinished (2 + 2*random());
	return TRUE;
};

vector SC_ZAD; // super boost

void(vector org, vector vec, float light1, string sd) HIP_LaunchLaser;

void(float ox) SCOURGE_FireSpikes =
{
	local vector   src, vec, zadj;
	local float vf;
	local string lns;

	ai_face();
	makevectors(self.angles);

	vf = 14;
	if (self.spawnflags & SC_SUPERS) vf = 34;
	if (self.spawnflags & SC_ULTRA)
	{
		vf = 110;
		ox = ox * 4.1;
	}
	if (self.spawnflags & SC_MINI) ox = ox / 3;
	if (!SC_ZAD) zadj = '0 0 17';
	else zadj = SC_ZAD;


	src = self.origin - zadj + v_right*ox + v_forward * vf;
	vec = (self.enemy.origin + (200*v_forward)) - src;
	vec = normalize(vec);

	if (self.aflag == SC_FIRE_LASER)
	{
		if ((self.spawnflags & SC_CTHON) || (self.spawnflags & 256)) // 256 - Lava scourge
		{
			Wiz_Firerep(1, 1, '0 0 0', 0.6 + random() * 0.4);
			newmis.origin = src;
			newmis.spawnflags = 2; // use cthon skin code
			if (self.spawnflags & 528)
			if (random() < 0.3)
				newmis.wad = "BIG";
		}
		else 
		{
			if (random() < 0.3) lns = "weapons/lasercannon/laserg.wav";
			vf = ceil(random() * 0.7);
			HIP_LaunchLaser(src, vec, vf, lns);
		}
	}
	else
	{
		sound (self, CHAN_WEAPON, "weapons/rocket1i.wav", 1, ATTN_NORM);
		launch_spike (src, vec);
	}

	newmis.netname = "monster_scourge";

	if ((self.spawnflags & SC_CTHON) || (self.spawnflags & 256)) // 256 - Lava scourge
		setmodel(newmis, "progs/nail.mdl");
// IMP: lava nails
	
	if (self.spawnflags & SC_SUPERS) // super size main missile
	{
		newmis.frame = SC_SPIKE_LG;
		newmis.dmg = sc_super_spike;
	}

	if (self.aflag == SC_FIRE_TRACK)
	{
		if (newmis.model != "progs/nail.mdl") // set above for lava skins
		{
			setmodel(newmis, "progs/nail.mdl");
			newmis.skin = 3;
		}
		Track_Missile(newmis, spike_touch, sc_track_dmg);
	}

//	newmis.velocity = v0; // TEST - stops missle for position check
//	newmis.nextthink =-1; // TEST - note: "= -1" does not seem to stop missiles in there tracks

	self.attack_finished = time + 0.2;
	if (self.speed > 0)
	{
		if (self.lip <= 0) self.lip = 1; // local speed divisor
		self.nextthink = time + (self.speed * MON_SPEED_DIV * self.lip);
	}
	self.lasttime = time + SC_POD_TIME;
};

// fire from expanded guns

void(float ox, float ud) SCOURGE_FireUDSpikes =
{
	SCOURGE_FireSpikes(ox);

	if (!self.spawnflags & SC_SUPERS) // min size missile for mega upper gun shots
		newmis.frame = SC_SPIKE_MIN;
	else
		newmis.dmg = 18;

	newmis.origin_z = newmis.origin_z + ud;
};

// Attack_With_Tail
//
void() Attack_With_Tail =
{
	ai_face ();

	self.cnt = 40; // damage mod
	if (self.spawnflags & SC_MINI) self.cnt = 15 + random() * 10;
	if (self.spawnflags & SC_MEGA) self.cnt = 60;
	self.dmg = (random() + random() + random()) * self.cnt;

	self.dest = self.enemy.origin - self.origin;
	self.cnt = 100; // range check
	if (self.spawnflags & SC_SUPERS)
	{
		self.cnt = 200; // range check
		self.dmg = (random() + random() + random()) * (30 + (self.spawnflags & SC_SUPERS) * 4);
	}

	if (vlen(self.dest) > self.cnt)
		return;
	if (!CanDamage (self.enemy, self))
		return;

	T_Damage (self.enemy, self, self, self.dmg);
	sound (self, CHAN_WEAPON, "shambler/smack.wav", 1, ATTN_NORM);

	SpawnMeatSpray (self.origin + v_forward*16, crandom() * 50 * v_right);

 	self.lasttime = time + SC_POD_TIME;
};

void() scourge_walk1;
void() ScourgeTriggerThink;
void() ScourgeTriggerTouch;

void() scourge_think =
{
	local entity trig;

	if (!self.spawnflags & SC_BABY)
	if (!self.state)
	{
		trig = spawn();
		trig.angles = '0 0 0';
		trig.solid = SOLID_TRIGGER;
		if (self.spawnflags & SC_MINI)
			setsize( trig, '-12 -12 -24', '12 12 12');
		else if (self.spawnflags & SC_SUPER6_EXTRA_MAD)
			setsize( trig, '-80 -80 -24', '80 80 80');
		else if (self.spawnflags & SC_ULTRA)
			setsize( trig, '-192 -192 -24', '192 192 128');
		else
		setsize( trig, '-64 -64 -24', '64 64 64');
		trig.takedamage = DAMAGE_NO;
		trig.movetype = MOVETYPE_NONE;
		trig.modelindex = 0;
		trig.model = null_string;
		trig.lastvictim = self;
		trig.think = ScourgeTriggerThink;
		trig.touch = ScourgeTriggerTouch;
		trig.nextthink = time + 0.1 + random();
		setorigin(trig,self.origin);
		self.lastvictim = trig;
		self.state = 1;
	}
	if ((self.spawnsilent == 0) && (self.spawnmulti == 1))
	{
		sound (self, CHAN_BODY, "misc/null.wav", 1, ATTN_IDLE);
	}
	else if ((self.spawnsilent == 1) && (self.spawnmulti == 0))
	{
		self.cnt = 1;
		if (self.spawnflags & SC_MINI) self.cnt = sc_mini_vol;
		if (self.spawnflags & SC_BABY) self.cnt = sc_baby_vol;
		sound (self, CHAN_BODY, self.noise2, self.cnt, ATTN_IDLE);
	}
	self.spawnmulti = self.spawnsilent;

// extended frames - baby, mini, mega, super, uber
	sc_run_frames();

// because these get stuck a lot
	if (time & 31 == 7) splinch_test();

// scourge evolutions
	if (SC_NEVOL)
	{
//		if (!self.spawnflags & SC_ULTRA) // already have super6 set
		if (!self.spawnflags & SC_SUPER6S) // even in no evolution, expand to 18 guns can happen
		if (self.spawnflags & SC_SUPER)
			xscourge_suxpand1();
	}
	else
	if (self.rad_time)
	if (self.rad_time < time)
	{
		self.rad_time = 0;

// baby & mini can always grow up - 7.28.14
		if (self.spawnflags & SC_MINI) // adolescent grows up
		{
			if (sc_count > sc_stop_grow) return;

			self.spawnflags = self.spawnflags - (self.spawnflags & SC_MINI);
			self.walkframe = 0;

			if (random() < 0.04)
				self.spawnflags = self.spawnflags | SC_MEGA;

			setsize (self, VEC_HULL2_MIN, VEC_HULL2_MAX);
			self.health = 300;
			self.max_health = 450;

			if (self.spawnflags & SC_MEGA)
			{
				self.health = 450;
				self.max_health = 600;

				self.netname = "Scourge";
				self.walkframe = $msstand1;
			}

			self.rad_time = time + 40 + (random() * 20) + (sc_radt_mult * sc_count);
			if (random() < 0.5) self.rad_time = time + 20 + (random() * 10) + sc_count;
//			self.lasttime = time + SC_POD_TIME;
			scourge_walk1();
			return;
		}

		if (self.spawnflags & SC_BABY) // baby gets his nail guns
		{
			self.rad_time = time + 50 + (random() * 10) + sc_count;
			if (sc_count > sc_stop_grow)
			{
// too many scourge - infant death syndrom
				if (random() < 0.25) T_Damage(self, self, self, self.health + 20);
				return;
			}

			self.spawnflags = self.spawnflags - (self.spawnflags & SC_BABY);
			self.spawnflags = self.spawnflags | SC_MINI;
			setsize (self, VEC_HULL_MIN, VEC_HULL_MAX);
			self.health = 150;

			self.walkframe = $memstand1;
			if (random() < 0.5) self.rad_time = time + 20 + (random() * 10) + (sc_count / 2); // they grow up so fast
			self.lasttime = 0;
			scourge_walk1();
			return;
		}

		if (!self.spawnflags & 8192) // check if growth is stunted by map flag - 7.28.14
		{
//			if (!self.spawnflags & SC_ULTRA) // super6 is set
			if (!self.spawnflags & SC_SUPER6S)
//			if (!self.spawnflags & SC_SUPER6_EXTRA_MAD)
			if (self.spawnflags & SC_SUPER)
				xscourge_suxpand1();
			else
			if (self.spawnflags & SC_MEGA)
				xscourge_mgrow1();
			else
				xscourge_msxpand1();
		}
	}

// scourge pods
	if (!SC_NEVOL) sc_pods();

};

void(float dist) ai_right =
{
	local float ddist;
	ddist = dist;

	if (self.speed > 0)
	{
		if (self.lip <= 0) self.lip = 1; // local speed divisor
		ddist = dist * ((0.1 / self.speed) / self.lip) / MON_SPEED_DIV;
		self.nextthink = time + (self.speed * MON_SPEED_DIV * self.lip);
	}

	walkmove ( (self.angles_y+90), ddist);
};

void(float dist) ai_left =
{
	local float ddist;
	ddist = dist;

	if (self.speed > 0)
	{
		if (self.lip <= 0) self.lip = 1; // local speed divisor
		ddist = dist * ((0.1 / self.speed) / self.lip) / MON_SPEED_DIV;
		self.nextthink = time + (self.speed * MON_SPEED_DIV * self.lip);
	}

	walkmove ( (self.angles_y+270), ddist);
};

//============================================================================

// regular scourge

void()   scourge_walk2;

//void() scourge_wake1;
void()   scourge_stand1  =[ $stand1, scourge_stand2  ]
{
	self.oldorigin = v0;
	self.spawnsilent = 0;
	ai_stand();
	scourge_think();
//	if (self.spawnflags & SC_BABY) { self.think = scourge_stand1; self.frame = $bultstand1; }
	if (self.spawnflags & SC_SUPER6_EXTRA_MAD) scourge_walk2(); // note - do we need now with new framing ?
};
void()   scourge_stand2  =[ $stand2, scourge_stand3  ] {self.spawnsilent = 0;ai_stand();scourge_think();};
void()   scourge_stand3  =[ $stand3, scourge_stand4  ] {self.spawnsilent = 0;ai_stand();scourge_think();xscourge_heal(0);};
void()   scourge_stand4  =[ $stand4, scourge_stand5  ] {self.spawnsilent = 0;ai_stand();scourge_think();};
void()   scourge_stand5  =[ $stand5, scourge_stand6  ] {self.spawnsilent = 0;ai_stand();scourge_think();};
void()   scourge_stand6  =[ $stand6, scourge_stand7  ] {self.spawnsilent = 0;ai_stand();scourge_think();xscourge_heal(0);self.oldorigin = v0;};
void()   scourge_stand7  =[ $stand7, scourge_stand8  ] {self.spawnsilent = 0;ai_stand();scourge_think();};
void()   scourge_stand8  =[ $stand8, scourge_stand9  ] {self.spawnsilent = 0;ai_stand();scourge_think();};
void()   scourge_stand9  =[ $stand9, scourge_stand10  ] {self.spawnsilent = 0;ai_stand();scourge_think();xscourge_heal(0);};
void()   scourge_stand10  =[ $stand10, scourge_stand11  ] {self.spawnsilent = 0;ai_stand();scourge_think();};
void()   scourge_stand11  =[ $stand11, scourge_stand12  ] {self.spawnsilent = 0;ai_stand();scourge_think();};
void()   scourge_stand12  =[ $stand12, scourge_stand1  ] {self.spawnsilent = 0;ai_stand();scourge_think();};

void()   scourge_walk1   =[ $walk1 , scourge_walk2   ]
{
	self.cnt = 1;
	if (self.spawnflags & SC_MINI) self.cnt = sc_mini_vol;
	if (self.spawnflags & SC_BABY) self.cnt = sc_baby_vol;

	if (random() < 0.1)
	{
		sound (self, CHAN_VOICE, self.noise, self.cnt, ATTN_IDLE);
	}

	self.spawnsilent = 1;
	scourge_think();
	ai_walk(8);
	if ((self.aflag == SC_FIRE_TRACK) || (self.aflag == SC_FIRE_LASER))
	if (random() < sc_track)
	{
		if ((!self.spawnflags & SC_SUPER6S) && (!self.spawnflags & SC_MEGA))
			self.aflag = 0;
		else
		self.aflag = SC_FIRE_TRIPLE; // after a tracker we auto upgrade to triple
	}
};
void()   scourge_walk2   =[ $walk2 , scourge_walk3   ] {ai_walk(8);sc_run_frames();};
void()   scourge_walk3   =[ $walk3 , scourge_walk4   ] {ai_walk(8);sc_run_frames();xscourge_heal(0.8);};
void()   scourge_walk4   =[ $walk4 , scourge_walk5   ] {ai_walk(8);sc_run_frames();};
void()   scourge_walk5   =[ $walk5 , scourge_walk6   ] {ai_walk(8);sc_run_frames();};
void()   scourge_walk6   =[ $walk6 , scourge_walk1   ] {ai_walk(8);sc_run_frames();};

void()   scourge_run1 =[ $walk1  , scourge_run2 ]
{
	local float vl;
		self.cnt = 1;
		if (self.spawnflags & SC_MINI) self.cnt = sc_mini_vol;
		if (self.spawnflags & SC_BABY) self.cnt = sc_baby_vol;

	if (random() < 0.1)
	{
		sound (self, CHAN_VOICE, self.noise, self.cnt, ATTN_IDLE);
	}

	self.spawnsilent = 1;
	scourge_think();
	ai_run(18);
	if ((self.aflag == SC_FIRE_TRACK) || (self.aflag == SC_FIRE_LASER))
	if (random() < (sc_track * 0.5))
	{
		if ((!self.spawnflags & SC_SUPER6S) && (!self.spawnflags & SC_MEGA))
			self.aflag = 0;
		else
		self.aflag = SC_FIRE_TRIPLE; // after a tracker we auto upgrade to triple
	}
};
void()   scourge_run2 =[ $walk2  , scourge_run3 ] {scourge_think();ai_run(14);};
void()   scourge_run3 =[ $walk3  , scourge_run4 ] {ai_run(14);sc_run_frames();xscourge_heal(0.6);};
void()   scourge_run4 =[ $walk4  , scourge_run5 ] {ai_run(14);sc_run_frames();};
void()   scourge_run5 =[ $walk5  , scourge_run6 ] {ai_run(14);sc_run_frames();};
void()   scourge_run6 =[ $walk6  , scourge_run1 ] {ai_run(14);sc_run_frames();};

void()   scourge_strafeleft1   =[ $walk1 , scourge_strafeleft2   ] {self.spawnsilent = 1;scourge_think();ai_left(20);};
void()   scourge_strafeleft2   =[ $walk2 , scourge_strafeleft3   ] {ai_left(20);sc_run_frames();};
void()   scourge_strafeleft3   =[ $walk3 , scourge_strafeleft4   ] {ai_left(20);sc_run_frames();xscourge_heal(0.6);};
void()   scourge_strafeleft4   =[ $walk4 , scourge_strafeleft5   ] {ai_left(14);sc_run_frames();};
void()   scourge_strafeleft5   =[ $walk5 , scourge_strafeleft6   ] {ai_left(14);sc_run_frames();};
void()   scourge_strafeleft6   =[ $walk6 , scourge_run1   ] {ai_left(14);sc_run_frames();};

void()   scourge_straferight1   =[ $walk1 , scourge_straferight2   ] {self.spawnsilent = 1;scourge_think();ai_right(20);};
void()   scourge_straferight2   =[ $walk2 , scourge_straferight3   ] {ai_right(20);sc_run_frames();};
void()   scourge_straferight3   =[ $walk3 , scourge_straferight4   ] {ai_right(20);sc_run_frames();xscourge_heal(0.6);};
void()   scourge_straferight4   =[ $walk4 , scourge_straferight5   ] {ai_right(14);sc_run_frames();};
void()   scourge_straferight5   =[ $walk5 , scourge_straferight6   ] {ai_right(14);sc_run_frames();};
void()   scourge_straferight6   =[ $walk6 , scourge_run1   ] {ai_right(14);sc_run_frames();};

/*
void()   scourge_wake1  =[ $stand2, scourge_wake2  ] {self.spawnsilent = 0;scourge_think();};
void()   scourge_wake2  =[ $stand3, scourge_wake3  ] {};
void()   scourge_wake3  =[ $stand4, scourge_wake4  ] {};
void()   scourge_wake4  =[ $stand5, scourge_wake5  ] {};
void()   scourge_wake5  =[ $stand6, scourge_wake6  ] {};
void()   scourge_wake6  =[ $stand7, scourge_run1  ]
	{
	SUB_AttackFinished(1);
	};
//void()   scourge_wake7  =[ $stand7, scourge_run1   ] {};
*/

void()   scourge_turn1  =[ $walk1, scourge_turn2  ] {self.spawnsilent = 1;scourge_think();ai_turn_in_place();};
void()   scourge_turn2  =[ $walk2, scourge_turn3  ] {ai_turn_in_place();sc_run_frames();};
void()   scourge_turn3  =[ $walk3, scourge_turn4  ] {ai_turn_in_place();sc_run_frames();};
void()   scourge_turn4  =[ $walk4, scourge_turn5  ] {ai_turn_in_place();sc_run_frames();};
void()   scourge_turn5  =[ $walk5, scourge_turn6  ] {ai_turn_in_place();sc_run_frames();};
void()   scourge_turn6  =[ $walk6, scourge_turn1  ] {ai_turn_in_place();sc_run_frames();};

// reg scourge or mega firing 2 ports per gun

void()   scourge_atk1 =[ $shoot1,   scourge_atk2 ]
{
	if (self.spawnflags & SC_MEGA)
	{
		if (random() < sc_track) self.aflag = SC_FIRE_TRACK;
		else
		if (random() < sc_laser) self.aflag = SC_FIRE_LASER;
	}

	SC_ZAD = v0;
	self.spawnsilent = 0;
	scourge_think();

	if (self.spawnflags & SC_BABY) return;

	self.effects = self.effects | EF_MUZZLEFLASH;
	SCOURGE_FireSpikes(40);
//   SCOURGE_FireSpikes(-40);
	if (self.spawnflags & SC_MEGA)
	{
		newmis.dmg = 18;
		SCOURGE_FireUDSpikes(-34, 10);
		if (self.aflag == SC_FIRE_TRIPLE)
		{
			SCOURGE_FireSpikes(-48);
		}
		self.frame = self.walkframe + $shootri1; // note - will adjust with ai_frame
	}
};
void()   scourge_atk2 =[ $shoot2,   scourge_atk3 ]
{
	sc_run_frames();

	if (self.spawnflags & SC_BABY)
	{
		if (random() < 0.5) scourge_run1();
		return;
	}
	if (self.spawnflags & SC_MINI) return;

	self.effects = self.effects | EF_MUZZLEFLASH;
//   SCOURGE_FireSpikes(56);
	SCOURGE_FireSpikes(-56);
	if (self.spawnflags & SC_MEGA)
	{
		newmis.dmg = 18;
		SCOURGE_FireUDSpikes(46, 10);
		if (self.aflag == SC_FIRE_TRIPLE)
		{
			SCOURGE_FireUDSpikes(-40, 10);
		}
		self.frame = self.walkframe + $shootri2; // note - will adjust with ai_frame
	}
};
void()   scourge_atk3 =[ $shoot1,   scourge_atk4 ]
{
	sc_run_frames();
	if (self.spawnflags & SC_BABY) return;

	self.effects = self.effects | EF_MUZZLEFLASH;
//   SCOURGE_FireSpikes(40);
	SCOURGE_FireSpikes(-40);
	if (self.spawnflags & SC_MEGA)
	{
		newmis.dmg = 18;
		SCOURGE_FireUDSpikes(34, 10);
		if (self.aflag == SC_FIRE_TRIPLE)
		{
			SCOURGE_FireSpikes(48);
		}
		self.frame = self.walkframe + $shootri3; // note - will adjust with ai_frame
	}
};
void()   scourge_atk4 =[ $shoot2,   scourge_atk5 ]
{
	sc_run_frames();

	if (self.spawnflags & SC_BABY)
	{
		scourge_run1();
		return;
	}
	if (self.spawnflags & SC_MINI) return;

	self.effects = self.effects | EF_MUZZLEFLASH;
	SCOURGE_FireSpikes(56);
//   SCOURGE_FireSpikes(-56);
	if (self.spawnflags & SC_MEGA)
	{
		newmis.dmg = 18;
		SCOURGE_FireUDSpikes(-46, 10);
		if (self.aflag == SC_FIRE_TRIPLE)
		{
			SCOURGE_FireSpikes(-48);
		}
		self.frame = self.walkframe + $shootri4; // note - will adjust with ai_frame
	}
};
void()   scourge_atk5 =[ $shoot1,   scourge_atk6 ]
{
	sc_run_frames();
	self.effects = self.effects | EF_MUZZLEFLASH;
	SCOURGE_FireSpikes(40);
//   SCOURGE_FireSpikes(-40);
	if (self.spawnflags & SC_MEGA)
	{
		newmis.dmg = 18;
		SCOURGE_FireUDSpikes(-34, 10);
		if (self.aflag == SC_FIRE_TRIPLE)
		{
			SCOURGE_FireUDSpikes(40, 10);
		}
		self.frame = self.walkframe + $shootri1; // note - will adjust with ai_frame
	}
};
void()   scourge_atk6 =[ $shoot2,   scourge_atk7 ]
{
	sc_run_frames();
	if (self.spawnflags & SC_MINI) return;

	self.effects = self.effects | EF_MUZZLEFLASH;
//   SCOURGE_FireSpikes(56);
	SCOURGE_FireSpikes(-56);
	if (self.spawnflags & SC_MEGA)
	{
		newmis.dmg = 18;
		SCOURGE_FireUDSpikes(46, 10);
		if (self.aflag == SC_FIRE_TRIPLE)
		{
			SCOURGE_FireSpikes(48);
		}
		self.frame = self.walkframe + $shootri2; // note - will adjust with ai_frame
	}
};
void()   scourge_atk7 =[ $shoot1,   scourge_atk8 ]
{
	sc_run_frames();
	self.effects = self.effects | EF_MUZZLEFLASH;
//   SCOURGE_FireSpikes(40);
	SCOURGE_FireSpikes(-40);
	if (self.spawnflags & SC_MEGA)
	{
		newmis.dmg = 18;
		SCOURGE_FireUDSpikes(34, 10);
		if (self.aflag == SC_FIRE_TRIPLE)
		{
			SCOURGE_FireUDSpikes(-40, 10);
		}
		self.frame = self.walkframe + $shootri3; // note - will adjust with ai_frame
	}
};
void()   scourge_atk8 =[ $shoot2,   scourge_run1 ]
// TEST
//void()   scourge_atk8 =[ $shoot2,   scourge_atk9 ]
{
	sc_run_frames();
	if (self.spawnflags & SC_MINI) return;

	self.effects = self.effects | EF_MUZZLEFLASH;
	SCOURGE_FireSpikes(56);
//   SCOURGE_FireSpikes(-56);
	if (self.spawnflags & SC_MEGA)
	{
		newmis.dmg = 18;
		SCOURGE_FireUDSpikes(-46, 10);
		if (self.aflag == SC_FIRE_TRIPLE)
		{
			SCOURGE_FireUDSpikes(40, 10);
		}
		self.frame = self.walkframe + $shootri4; // note - will adjust with ai_frame
	}
	SUB_AttackFinished (4*random());
};

// TEST
void()   scourge_atk9 =[ $shoot1,   scourge_atk9 ]
{
//	if (self.spawnflags & SC_MEGA) // note - will adjust with ai_frame
//	{
//		self.frame = $shoot1;
//	}
}; 

// super, super6, super6em

/*
regular scourge offsets, main, second guns
runs 8 frames - fires 8 spikes, mega fires 16 spikes

40			-34
-56		46
-40		34
56			-46
40			-34
-56		46
-40		34
56			-46

6 by 2x guns

fires 8 big spikes & 16 small spikes

6 by 3x guns

fires 12 big spikes & 24 small spikes


*/
void()   xscourge_atk1 =[ $shoot1,   xscourge_atk2 ]
{
	if (!self.spawnflags & SC_SUPERS) // not super scourge - oops
	{
#ifdef warning
bprint(" *** - WARNING: in super scourge missile, & no super flags!\n"); // TEST
#endifdef
		self.th_missile = scourge_atk1;
		scourge_atk1();
		return;
	}

	if (random() < sc_track) self.aflag = SC_FIRE_TRACK;
	else
	if (random() < sc_laser) self.aflag = SC_FIRE_LASER;

	self.spawnsilent = 0;
	scourge_think();
	self.effects = self.effects | EF_MUZZLEFLASH;

	if (self.spawnflags & SC_ULTRA)
		SC_ZAD = '0 0 -50';
	else
	if (self.spawnflags & SC_SUPER6_EXTRA_MAD)
		SC_ZAD = '0 0 -16';
	else
	if (self.spawnflags & SC_SUPER6)
		SC_ZAD = '0 0 -10';
	else
		SC_ZAD = '0 0 4';

	if (self.aflag == SC_FIRE_TRIPLE)
	{
		self.frame = $shootri1 + self.walkframe;
// main guns
		SCOURGE_FireSpikes(40);
		SCOURGE_FireSpikes(56);
		SCOURGE_FireSpikes(-48); // center spike
// extended guns
		SCOURGE_FireUDSpikes(-34, 16);
		SCOURGE_FireUDSpikes(-46, 16);
		SCOURGE_FireUDSpikes(40, 16); // center spike

		SCOURGE_FireUDSpikes(-34, -16);
		SCOURGE_FireUDSpikes(-46, -16);
		SCOURGE_FireUDSpikes(40, -16); // center spike
	}
	else
	{
		SCOURGE_FireSpikes(40);
		SCOURGE_FireSpikes(-40);

		if (self.spawnflags & SC_SUPER6)
		{
			SCOURGE_FireUDSpikes(-34, 16);
			SCOURGE_FireUDSpikes(34, 16);
			SCOURGE_FireUDSpikes(46, -16);
			SCOURGE_FireUDSpikes(-46, -16);
		}
	}
	SC_ZAD = v0;
};
void()   xscourge_atk2 =[ $shoot2,   xscourge_atk3 ]
	{
	sc_run_frames();
	self.effects = self.effects | EF_MUZZLEFLASH;

	if (self.spawnflags & SC_ULTRA)
		SC_ZAD = '0 0 -50';
	else
	if (self.spawnflags & SC_SUPER6_EXTRA_MAD)
		SC_ZAD = '0 0 -16';
	else
	if (self.spawnflags & SC_SUPER6)
		SC_ZAD = '0 0 -10';
	else
		SC_ZAD = '0 0 4';

	if (self.aflag == SC_FIRE_TRIPLE)
	{
		self.frame = $shootri2 + self.walkframe;
// main guns
		SCOURGE_FireSpikes(-40);
		SCOURGE_FireSpikes(-56);
		SCOURGE_FireSpikes(48); // center spike
// extended guns
		SCOURGE_FireUDSpikes(34, 16);
		SCOURGE_FireUDSpikes(46, 16);
		SCOURGE_FireUDSpikes(-40, 16);

		SCOURGE_FireUDSpikes(34, -16);
		SCOURGE_FireUDSpikes(46, -16);
		SCOURGE_FireUDSpikes(-40, -16);
	}
	else
	{
		SCOURGE_FireSpikes(56);
		SCOURGE_FireSpikes(-56);
		if (self.spawnflags & SC_SUPER6)
		{
			SCOURGE_FireUDSpikes(46, 16);
			SCOURGE_FireUDSpikes(-46, 16);
			SCOURGE_FireUDSpikes(-34, -16);
			SCOURGE_FireUDSpikes(34, -16);
		}
	}
	SC_ZAD = v0;
};
void()   xscourge_atk3 =[ $shoot1,   xscourge_atk4 ]
{
	sc_run_frames();
	self.effects = self.effects | EF_MUZZLEFLASH;

	if (self.spawnflags & SC_ULTRA)
		SC_ZAD = '0 0 -50';
	else
	if (self.spawnflags & SC_SUPER6_EXTRA_MAD)
		SC_ZAD = '0 0 -16';
	else
	if (self.spawnflags & SC_SUPER6)
		SC_ZAD = '0 0 -10';
	else
		SC_ZAD = '0 0 4';

	if (self.aflag == SC_FIRE_TRIPLE)
	{
		self.frame = $shootri3 + self.walkframe;
// main guns
		SCOURGE_FireSpikes(40);
		SCOURGE_FireSpikes(56);
		SCOURGE_FireSpikes(-48); // center spike
// extended guns
		SCOURGE_FireUDSpikes(-34, 16);
		SCOURGE_FireUDSpikes(-46, 16);
		SCOURGE_FireUDSpikes(40, 16);

		SCOURGE_FireUDSpikes(-34, -16);
		SCOURGE_FireUDSpikes(-46, -16);
		SCOURGE_FireUDSpikes(40, -16);
	}
	else
	{
		SCOURGE_FireSpikes(40);
		SCOURGE_FireSpikes(-40);
		if (self.spawnflags & SC_SUPER6)
		{
			SCOURGE_FireUDSpikes(34, 16);
			SCOURGE_FireUDSpikes(-34, 16);
			SCOURGE_FireUDSpikes(46, -16);
			SCOURGE_FireUDSpikes(-46, -16);
		}
	}
	SC_ZAD = v0;
};
void()   xscourge_atk4 =[ $shoot2,   scourge_run1 ]
// TEST
//void()   xscourge_atk4 =[ $shoot2,   xscourge_atk9 ]
{
	sc_run_frames();
	self.effects = self.effects | EF_MUZZLEFLASH;

	if (self.spawnflags & SC_ULTRA)
		SC_ZAD = '0 0 -50';
	else
	if (self.spawnflags & SC_SUPER6_EXTRA_MAD)
		SC_ZAD = '0 0 -16';
	else
	if (self.spawnflags & SC_SUPER6)
		SC_ZAD = '0 0 -10';
	else
		SC_ZAD = '0 0 4';

	if (self.aflag == SC_FIRE_TRIPLE)
	{
		self.frame = $shootri4 + self.walkframe;
// main guns
		SCOURGE_FireSpikes(-40);
		SCOURGE_FireSpikes(-56);
		SCOURGE_FireSpikes(48); // center spike
// extended guns
		SCOURGE_FireUDSpikes(34, 16);
		SCOURGE_FireUDSpikes(46, 16);
		SCOURGE_FireUDSpikes(-40, 16);

		SCOURGE_FireUDSpikes(34, -16);
		SCOURGE_FireUDSpikes(46, -16);
		SCOURGE_FireUDSpikes(-40, -16);
	}
	else
	{
		SCOURGE_FireSpikes(56);
		SCOURGE_FireSpikes(-56);
		if (self.spawnflags & SC_SUPER6)
		{
			SCOURGE_FireUDSpikes(-46, 16);
			SCOURGE_FireUDSpikes(46, 16);
			SCOURGE_FireUDSpikes(-34, -16);
			SCOURGE_FireUDSpikes(34, -16);
		}
	}
	SC_ZAD = v0;
};

// TEST
void()   xscourge_atk9 =[ $shoot1,   xscourge_atk9 ]
{
	sc_run_frames();
}; 


void()   scourge_melee1 =[ $sting1,   scourge_melee2 ] {self.spawnsilent = 0;scourge_think();ai_charge(3);};
void()   scourge_melee2 =[ $sting2,   scourge_melee3 ] {ai_charge(3);sc_run_frames();};
void()   scourge_melee3 =[ $sting3,   scourge_melee4 ]
{
	ai_charge(2);
	sc_run_frames();
	xscourge_heal(0.2);
	if (self.spawnflags & SC_BABY) self.think = scourge_run1; // baby cant sting - only 3 frames
};
void()   scourge_melee4 =[ $sting4,   scourge_melee5 ] {ai_charge(2);sc_run_frames();};
void()   scourge_melee5 =[ $sting5,   scourge_melee6 ]
	{
	sound (self, CHAN_WEAPON, "scourge/tailswng.wav", 1, ATTN_NORM);
	ai_charge(3);
	sc_run_frames();
	};
void()   scourge_melee6 =[ $sting6,   scourge_melee7 ] {ai_charge(1);sc_run_frames();};
void()   scourge_melee7   =[ $sting7,   scourge_melee8   ]
	{
	Attack_With_Tail();
	sc_run_frames();
	};
void()   scourge_melee8   =[ $sting8,   scourge_melee9   ] {ai_face();sc_run_frames();};
void()   scourge_melee9   =[ $sting9,   scourge_melee10   ] {ai_face();sc_run_frames();};
void()   scourge_melee10   =[ $sting10,   scourge_melee11   ] {ai_face();sc_run_frames();};
void()   scourge_melee11   =[ $sting11,  scourge_run1 ] {ai_face();
SUB_CheckRefire (scourge_melee1);
sc_run_frames();
};

void()   scourge_pain1  =[ $pain1, scourge_pain2  ] {self.spawnsilent = 0;scourge_think();};
void()   scourge_pain2  =[ $pain2, scourge_pain3  ] {sc_run_frames();};
void()   scourge_pain3  =[ $pain3, scourge_pain4  ] {sc_run_frames();};
void()   scourge_pain4  =[ $pain4, scourge_pain5  ] {sc_run_frames();};
void()   scourge_pain5  =[ $pain5, scourge_run1 ] {sc_run_frames();};

void()   scourge_die1 =[ $death1, scourge_die2 ] {self.spawnsilent = 0;scourge_think();};
void()   scourge_die2 =[ $death2, scourge_die3 ] {sc_run_frames();};
void()   scourge_die3 =[ $death3, scourge_die4 ] {self.solid = SOLID_NOT;sc_run_frames();};
void()   scourge_die4 =[ $death4, scourge_die5 ] {sc_run_frames();};
void()   scourge_die5 =[ $death5, scourge_die5 ]
{
	sc_run_frames();

	if (!SC_NEVOL)
	if (!self.spawnflags & SC_WEE)
	if (sc_count < SC_MAX)
	if (random() < sc_dead_pod) // make a corpse pod
	{
		pod_make(TRUE);
		newmis.frame = self.frame;
		newmis.angles = self.angles;
		self.model = null_string;
		self.nextthink = -1;
	}
};


//============================================================================

// grow & expand

// scourge growth cycle

//     /----<		Uber / Ultra			>----\
// pod
//    |
// baby -> mini -> scourge -> mega -> super 6x -> super 6x XMAD
//																\
//																 > super -> super 6x -> super 6x XMAD
//

// to mega scourge - 2 of 2x guns to 4 of 3x guns
void()   xscourge_msxpand1  =[ $tgexpand1, xscourge_msxpand2 ] {};
void()   xscourge_msxpand2  =[ $tgexpand2, xscourge_msxpand3 ] {};
void()   xscourge_msxpand3  =[ $tgexpand3, xscourge_msxpand4 ] {};
void()   xscourge_msxpand4  =[ $tgexpand4, xscourge_msxpand5 ] {};
void()   xscourge_msxpand5  =[ $tgexpand5, xscourge_msxpand6 ] {};
void()   xscourge_msxpand6  =[ $tgexpand6, scourge_run1 ]
{
	self.spawnflags = self.spawnflags | SC_MEGA;
	self.walkframe = $msstand1;
//   self.th_missile = scourge_atk1; // uses same attack vector

	self.netname = "Scourge";

	if (random() < 0.3) self.rad_time = time + 80 + random() * 30 + (sc_radt_mult * sc_count);
	if (self.health < 400) self.health = self.health + 100 + random() * 100;
	self.max_health = 600;
};

// super scourge - 2 of 2x guns to 6 of 3x guns
void()   xscourge_suxpand1  =[ $sxgexpand1, xscourge_suxpand2 ] {};
void()   xscourge_suxpand2  =[ $sxgexpand2, xscourge_suxpand3 ] {};
void()   xscourge_suxpand3  =[ $sxgexpand3, xscourge_suxpand4 ] {};
void()   xscourge_suxpand4  =[ $sxgexpand4, xscourge_suxpand5 ] {};
void()   xscourge_suxpand5  =[ $sxgexpand5, xscourge_suxpand6 ] {};
void()   xscourge_suxpand6  =[ $sxgexpand6, scourge_run1 ]
{
	self.spawnflags = self.spawnflags | SC_SUPER6;
	self.walkframe = $sxstand1;
	self.th_missile = xscourge_atk1;

	if (self.health < 0) // we died & had to expand for these death frames
	{
	   scourge_die1();
		return;
	}

	self.rad_time = 0;
	if (self.health < 600) self.health = 600 + random() * 200;
	self.max_health = 1100;
};

// scrouge to super - 2 of 2x guns

void()   xscourge_grow1  =[ $scgrow1, xscourge_grow2 ]
{
	setmodel (self, "progs/scor2e.mdl");
	setsize (self, VEC_HULL2_MIN, VEC_HULL2_MAX);
};
void()   xscourge_grow2  =[ $scgrow2, xscourge_grow3 ] {};
void()   xscourge_grow3  =[ $scgrow3, xscourge_grow4 ] {};
void()   xscourge_grow4  =[ $scgrow4, xscourge_grow5 ] {};
void()   xscourge_grow5  =[ $scgrow5, xscourge_grow6 ] {};
void()   xscourge_grow6  =[ $scgrow6, scourge_run1 ]
{
	self.spawnflags = self.spawnflags | SC_SUPER;
	self.walkframe = $stand1;
	self.th_missile = xscourge_atk1;

	self.netname = "Scourge";

	self.rad_time = time + 80 + random() * 30 + (sc_radt_mult * sc_count);
	if (self.health < 600) self.health = 600 + random() * 150;
	self.max_health = 900;
};

// mega scrouge to super - 4 of 3x guns to 6 of 3x guns

void()   xscourge_mgrow1  =[ $smgrow1, xscourge_mgrow2 ]
{
	setmodel (self, "progs/scor2e.mdl");
	setsize (self, VEC_HULL2_MIN, VEC_HULL2_MAX);
};
void()   xscourge_mgrow2  =[ $smgrow2, xscourge_mgrow3 ] {};
void()   xscourge_mgrow3  =[ $smgrow3, xscourge_mgrow4 ] {};
void()   xscourge_mgrow4  =[ $smgrow4, xscourge_mgrow5 ] {};
void()   xscourge_mgrow5  =[ $smgrow5, xscourge_mgrow6 ] {};
void()   xscourge_mgrow6  =[ $smgrow6, xscourge_mgrow7 ] {};
void()   xscourge_mgrow7  =[ $smgrow7, scourge_run1 ]
{
//	self.spawnflags = self.spawnflags - (self.spawnflags & SC_MEGA);
	self.spawnflags = self.spawnflags | SC_SUPER6;
	self.walkframe = $sxstand1;
	self.th_missile = xscourge_atk1;

	self.netname = "Scourge";

	self.rad_time = 0;
	if (self.health < 600) self.health = 600 + random() * 300;
	self.max_health = 1100;
};

// super scrouge to EXTRA MAD - 6 of 3x guns

void()   xscourge_sugrow1  =[ $sxgrow1, xscourge_sugrow2 ] {};
void()   xscourge_sugrow2  =[ $sxgrow2, xscourge_sugrow3 ] {};
void()   xscourge_sugrow3  =[ $sxgrow3, xscourge_sugrow4 ] {};
void()   xscourge_sugrow4  =[ $sxgrow4, xscourge_sugrow5 ] {};
void()   xscourge_sugrow5  =[ $sxgrow5, xscourge_sugrow6 ] {};
void()   xscourge_sugrow6  =[ $sxgrow6, xscourge_sugrow7 ] {};
void()   xscourge_sugrow7  =[ $sxgrow7, xscourge_sugrow8 ] {};
void()   xscourge_sugrow8  =[ $sxgrow8, xscourge_sugrow9 ] {};
void()   xscourge_sugrow9  =[ $sxgrow9, xscourge_sugrow10 ] {};
void()   xscourge_sugrow10  =[ $sxgrow10, scourge_run1 ]
{
	self.spawnflags = self.spawnflags | SC_SUPER6_EXTRA_MAD;
	self.walkframe = $memstand1; // note - no stand frames
	self.th_missile = xscourge_atk1;
	self.aflag = SC_FIRE_TRIPLE;

	self.netname = "Scourge";

	self.rad_time = 0;
	if (self.health < 1100) self.health = 1200 + random() * 600;
	self.max_health = 5000;
};

//============================================================================

// multiplex for all scourge

void(entity attacker, float damage) scourge_pain =
{
	self.dmg = 50;
	if (self.spawnflags & SC_BABY) self.dmg = 30;
	if (self.spawnflags & SC_MEGA) self.dmg = 75;
	if (self.spawnflags & SC_SUPER) self.dmg = 100;
	if (self.spawnflags & SC_SUPER6) self.dmg = 150;
	if (self.spawnflags & SC_ULTRA) self.dmg = 1000;
//	if (self.spawnflags & SC_SUPER6_EXTRA_MAD) self.dmg = 300; // extra mad - no pain
	if (self.spawnflags & SC_CTHON) self.dmg = self.dmg * 1.5;
//	if (self.spawnflags & 256) self.dmg = self.dmg * 1.35;


	if (self.pain_finished > time)
		return;

	if (self.spawnflags & SC_SUPERS)
	{
// check to see if scrg expands to 6
		if (!self.spawnflags & SC_SUPER6)
//		if (self.health < 400 || random() < 0.4)
		if (self.health < 100 || random() < 0.4)
				xscourge_suxpand1();

// check to see if scrg gets EXTRA mad
		if (self.spawnflags & SC_SUPER6) // have to be 6 x first
		{
			if ((!self.spawnflags & SC_ULTRA) && (!self.spawnflags & SC_SUPER6_EXTRA_MAD))
			{
				if (random() < 0.05)
					self.spawnflags = self.spawnflags | SC_SUPER6_EXTRA_MAD;

				if (self.health < 300)
				if (random() < 0.5)
					self.spawnflags = self.spawnflags | SC_SUPER6_EXTRA_MAD;

				if (self.health < 100)
					self.spawnflags = self.spawnflags | SC_SUPER6_EXTRA_MAD;

	// just like the hulk - super gets bigger & a health boost when going to extra mad
				if (self.spawnflags & SC_SUPER6_EXTRA_MAD)
				{
					self.wad = "SUPER_XMAD";
					xscourge_sugrow1();
				}
			}
// could make this one dangerous brute
			else
			if (random() < sc_emheal_chn)
				self.health = self.health + (sc_emheal * random());
		}

		if (self.speed > mon_superspeedup_max)
		if (random() < mon_superspeed_chn)
		{
			self.speed  = self.speed - mon_superspeed_fact;
			if (self.speed < mon_superspeedup_max) self.speed = mon_superspeedup_max;
		}

		self.pain_finished = time + 3; // set a default

		if (self.spawnflags & SC_SUPER6_EXTRA_MAD) return;

		if (random() > 0.75) return;
	}
	else
	{
		self.cnt = 0.03;
		if (self.health < 100) self.cnt = 0.06;
	// chance to go super
#ifdef enhanced
//		if (ENHANCED)
		if (ENH_Q1_MAP_MONSTERS)
		if (!SC_NEVOL)
		if (!self.spawnflags & 8192) // check if growth is stunted by map flag - 7.28.14
		if (random() < self.cnt)
		{
			if (self.spawnflags & SC_MEGA) xscourge_mgrow1();
			else xscourge_grow1();
			return;
		}
#endifdef
	}

//   if (random()*50 > damage)
	if (random() * self.dmg > damage)
		return;		// didn't flinch

	self.pain_finished = time + 2.0;

	self.cnt = 1;
	if (self.spawnflags & SC_MINI) self.cnt = sc_mini_vol;
	if (self.spawnflags & SC_BABY) self.cnt = sc_baby_vol;

	sound (self, CHAN_VOICE, self.noise3, self.cnt, ATTN_NORM);

/*
	if ((self.spawnflags & SC_SUPERS) == SC_SUPER)
//	if (!self.spawnflags & SC_SUPER6S)
	{
		scourge_stand8(); // because super does not have pain frames
		return;
	}
	
	if (self.spawnflags & SC_BABY) // baby doesnt have pain frames
		scourge_walk2();
	else
*/

//	if (self.spawnflags & SC_FRAMED) xscourge_pain1();
//	else
	scourge_pain1();
};


void() scourge_die =
{
// check for gib

	self.dmg = -35;
	if (self.spawnflags & SC_BABY) self.dmg = -20;
	if (self.spawnflags & SC_MEGA) self.dmg = -50;
	if (self.spawnflags & SC_SUPER) self.dmg = -100;
	if (self.spawnflags & SC_SUPER6) self.dmg = -140;
	if (self.spawnflags & SC_SUPER6_EXTRA_MAD) self.dmg = -300;
	if (self.spawnflags & SC_ULTRA) self.dmg = -4000;

	remove (self.lastvictim); // dodge trigger
// stop sound
	self.spawnmulti = self.spawnsilent = 0;
	sound (self, CHAN_BODY, "misc/null.wav", 1, ATTN_IDLE);
	self.lasttime = self.rad_time = 0; // no pods, upgrades or healing when dying
//   scourge_think();

	sc_count = sc_count - 1;
	if (sc_count < 0) sc_count = 0;

	if ((self.health < self.dmg) || (self.state == AS_SPLINCH))
	{		
		if (self.state == AS_SPLINCH) // when splinching and count is low, chance for a pod
		if (sc_count < 10)
		if (!SC_NEVOL)
		if (!self.spawnflags & SC_WEE)
		if (random() < 0.4) pod_make(TRUE);

		sound (self, CHAN_VOICE, "player/udeath.wav", 1, ATTN_NORM);
// integrated head
//		ThrowHead ("progs/scor2.mdl", self.health);
		ThrowHead (self.model, self.health);
		if (!self.skin) self.skin = 3; // bloody head skin

		if (self.spawnflags & SC_ULTRA) self.frame = $head3;
		else if (self.spawnflags & SC_SUPER6_EXTRA_MAD) self.frame = $head2;
		else if (self.spawnflags & SC_MINI) self.frame = $head2;
		else if (self.spawnflags & SC_BABY) self.frame = $head3;
		else self.frame = $head1;

// IMP: more gibs for supers - scrg specific gibs
		ThrowGib ("progs/gib1.mdl", self.health);
		ThrowGib ("progs/gib2.mdl", self.health);
		ThrowGib ("progs/gib3.mdl", self.health);
		return;
	}
// integrated severed head - reg - mini - baby, sup - supxm - ultra

//$frame head1 head2 head3 

// regular death
	sound (self, CHAN_VOICE, self.noise4, 1, ATTN_NORM);
/*
	if (self.spawnflags & SC_BABY) // must get offset for proper death seq.
	self.walkframe = $minsting11 - 8;

	if (self.spawnflags & SC_SUPER6_EXTRA_MAD) // must get offset for proper death seq.
		self.walkframe = $sxstand1;
	if ((self.spawnflags & SC_SUPERS) == SC_SUPER)
//	if (!self.spawnflags & SC_SUPER6S)
	{
		xscourge_suxpand1(); // because super does not have death frames
		return;
	}
*/

	scourge_die1();
};

//
// scourge_melee
//
void() scourge_melee =
{
	if ((self.spawnflags & SC_SUPERS) == SC_SUPER)
	{
		self.th_missile(); // because super does not have sting frames
		return;
	}

//   chance = random();
//   if (chance < 0.5 )
//      {
		scourge_melee1();
//      }
//   else
//      return;
	SUB_AttackFinished (2*random());
};

//============================================================================

// a decent attempt to dodge missile objects

//
// ScourgeTriggerThink
//
void() ScourgeTriggerThink =
	{
	local entity targ;

	if (self.lastvictim.health<=0)
		{
		remove(self);
		return;
		}
	targ = self.lastvictim;
	makevectors(targ.angles);
	setorigin(self, targ.origin + (v_forward*300) ); // stay in front of scourge for dodge of on coming missiles
	self.nextthink = time + 0.1;
	};

//
// ScourgeTriggerTouch
//
void() ScourgeTriggerTouch =
	{
	local entity targ;
	local entity tempent;
	local vector dir;

	if (other.flags & (FL_MONSTER|FL_CLIENT))
		return;
	if (other.movetype != MOVETYPE_FLYMISSILE)
		return;
	targ = self.lastvictim;
	if (targ.health<=0)
		{
		remove(self);
		return;
		}
	dir = targ.origin - other.origin;
	dir = normalize(dir);
	if ((dir * normalize(other.velocity))<0.8)
		return;

//   targ.think = targ.th_run;
//   if (targ.flags & FL_ONGROUND)
//      {
		if (time > self.duration)
			{
			tempent = self;
			self = targ;
			if (random()<0.5)
				scourge_strafeleft1();
			else
				scourge_straferight1();
			self.duration = time + 1.5;
			}
/*
		targ.origin_z = targ.origin_z + 1;
		targ.velocity = targ.velocity + '0 0 500';
		targ.flags = targ.flags - FL_ONGROUND;
*/
		self = tempent;
//      }
//   dprint("ouch\n");
	};

//============================================================================

/*QUAKED monster_scourge (1 0 0) (-16 -16 -24) (16 16 40) Ambush Mega Super Super6 XMAD Mini Baby Cthon Lava ULTRA Poison Death Wraith stunt

" Mega" - 2 extra 3x nailguns, a bit tougher
"Super" - double size, double bad
"Super6" - double size with 4 extra 3x nailguns, ton tougher
"XMAD" - triple sized - has plate stenciled "bad ass motherfucker"
"Mini" - mini scrourges, take after mommy
"Baby" - wee little baby scourge - aww...arent they cute
"Cthon" - Cthon scourge - toughest
"Lava" - Lava skin scourge - tougher
"ULTRA" - ultimate Uber scourge - the "big" mommy
"stunt" - do NOT allow this scourge to "evolve" into more powerful scourge
				^^^^^
not implemented:
"Poison" - has poisoned nails, stinger, green skin
"Death" - death scourge
"Wraith" - wraith scourge
These will make regular scourge
*/
void(float ign) monster_scourge =
{

if (ign != A_MONSTER) // only map monsters run this code
{
	if (M_MONSTER < 0)
	{
		self.think = remove_monster;
		self.nextthink = time + 2 + (random() * REMOVE_MON_SPREAD);
		return;
	}

	if (!M_MONSTER & CB_M_SCOURGE)
	if (deathmatch)
	{
		if (R_MONSTER)
			remove(self);
		return;
	}

// make some more random monsters according to server rules - only do this on map spawned monsters, wont happen with random monsters
	if (R_FAST_MONSTER & CB_M_SCOURGE)
	if (random() < C_FS_MONSTER)
		speed_monster(CFAST, "monster_scourge", self.origin);
		
	if (R_SLOW_MONSTER & CB_M_SCOURGE)
	if (random() < C_FS_MONSTER)
		speed_monster(CSLOW, "monster_scourge", self.origin);

	precache_model ("progs/scor2c.mdl");
	precache_model ("progs/scor2e.mdl");
	precache_model ("progs/h_scourg.mdl");
	precache_model ("progs/laser.mdl");
	precache_model ("progs/s_light.mdl");
	precache_model ("progs/spike.mdl");
	precache_model ("progs/nail.mdl");

	precache_sound ("misc/null.wav");
	precache_sound ("scourge/idle.wav");
	precache_sound ("scourge/pain.wav");
	precache_sound ("scourge/pain2.wav");
	precache_sound ("scourge/sight.wav");
	precache_sound ("scourge/tailswng.wav");
	precache_sound ("scourge/walk.wav");
	precache_sound ("shambler/smack.wav");
	precache_sound ("weapons/rocket1i.wav");

// little lad
	precache_sound ("scourge/walk2m.wav"); // n2
	precache_sound ("scourge/pain2m.wav"); // n3
	precache_sound ("scourge/pain1m.wav"); // n4
	precache_sound ("scourge/idle2m.wav");  // n
	precache_sound ("scourge/sight2m.wav"); // n1

// wee baby
	precache_sound ("scourge/pain2b.wav");
	precache_sound ("scourge/pain1b.wav");

// ultra monster
	precache_sound ("scourge/sight3u.wav");
	precache_sound ("scourge/idle3u.wav");
	precache_sound ("scourge/walk3u.wav");
	precache_sound ("scourge/pain3u.wav");
}

// new noise system for mini & baby with different sounds
	self.noise = "scourge/idle.wav";
	self.noise1 = "scourge/sight.wav";
	self.noise2 = "scourge/walk.wav";
	self.noise3 = "scourge/pain.wav";
	self.noise4 = "scourge/pain2.wav";

	if (!SC_MAX)
	{
		SC_MAX = 256;
		sc_stop_grow = SC_MAX / 2;
	}

	if (ign)
	if (sc_count >= SC_MAX)
	{
		self.stack1 = "no_monster_wakey";
		self.think = SUB_Remove;
		self.nextthink = time + 0.5;
		return;
	}

	sc_count = sc_count + 1;

// Cataboligne - 11.14.12 - fast / slow code
	if (self.speed <= 0) self.speed = MON_NORM;
	self.lip = 1; // local speed divisor
// map specced
	if (self.netname == CFAST) self.speed = MON_FAST;
	else if (self.netname == CSLOW) self.speed = MON_SLOW;

// server controls set all monsters fast or slow if not specced - this includes random monsters
	else if (FAST_MONSTER & CB_M_SCOURGE) self.speed = MON_FAST;
	else if (SLOW_MONSTER & CB_M_SCOURGE) self.speed = MON_SLOW;

	self.netname = "Centroid";

	self.solid = SOLID_SLIDEBOX;
	self.movetype = MOVETYPE_STEP;
	self.walkframe = 0;


	setmodel (self, "progs/scor2c.mdl");

	enhance = FALSE;

	self.spawnflags = self.spawnflags | self.height; // code in because of 256+ issues
	self.height = 0;

#ifdef enhanced
//	if (ENHANCED)
	if (ENH_Q1_MAP_MONSTERS || (ign == A_MONSTER))
		enhance = TRUE;
#endifdef

	if ((enhance) || (self.spawnflags & SC_TYPE))
	{
		chance = sc_imp;
		if (ign == A_MONSTER) chance = sc_rnd;

		if (!self.spawnflags & SC_TYPE) // not map specced - enhance him
		if (random() < chance)
		{
			if (random() > 0.9) self.spawnflags = self.spawnflags | SC_SUPER; // not many of these guys
			else self.spawnflags = self.spawnflags | SC_MEGA;

			if (random() < sc_cth)
				self.spawnflags = self.spawnflags | SC_CTHON;
//			else if (r < 0.4)
//				self.spawnflags = self.spawnflags | 256;
		}

// special cfg
	}

	self.walkframe = 0;
	self.th_missile = scourge_atk1;

// pod time
	if (ign != A_MONSTER) self.lasttime = time + (SC_POD_TIME * 2.5); // because map scourge could be sitting around for a while
	else
		self.lasttime = time + SC_POD_TIME;

	if (SC_NEVOL)
	{
		self.spawnflags = self.spawnflags - (self.spawnflags & SC_WEE);
//		self.spawnflags = self.spawnflags - (self.spawnflags & SC_MINI);
	}

	if (self.spawnflags & SC_ULTRA)
	{
		self.health = 4000 + 500 * random();
		self.max_health = 20000;

		self.th_missile = xscourge_atk1;

		self.spawnflags = self.spawnflags | SC_SUPER6; // 6 for attack modes, etc
		self.netname = "Ultra Scourge";
		self.rad_time = time + 120 + random() * 45 + (sc_radt_mult * sc_count);

		self.walkframe = $bultstand1;
		setmodel (self, "progs/scor2e.mdl");
		setsize (self, '-128 -128 -24', '128 128 128'); // note: prob. too small

		self.noise = "scourge/idle3u.wav";
		self.noise1 = "scourge/sight3u.wav";
		self.noise2 = "scourge/walk3u.wav";
		self.noise3 = "scourge/pain3u.wav"; // does ultra even have pain?
		self.noise4 = "scourge/pain3u.wav";
	}
	else
	if (self.spawnflags & SC_SUPER)
	{
		self.health = 600 + 200 * random();
		self.max_health = 900;

		self.th_missile = xscourge_atk1;

		self.netname = "Scourge";
		self.rad_time = time + 60 + random() * 30 + (sc_radt_mult * sc_count);

		self.walkframe = $stand1;
		setmodel (self, "progs/scor2e.mdl");
		setsize (self, VEC_HULL2_MIN, VEC_HULL2_MAX);
	}
	else
	if (self.spawnflags & SC_MEGA)
	{
//		setsize (self, VEC_HULL2_MIN, VEC_HULL2_MAX);
		setsize (self, '-24 -24 -24', '24 24 24');
		self.health = 450;
		self.max_health = 600;

		self.netname = "Scourge";
		self.walkframe = $msstand1;
		if (enhance)
		if (random() < 0.6) self.rad_time = time + 60 + random() * 40 + (sc_radt_mult * sc_count);
		if (ign != A_MONSTER) self.rad_time = self.rad_time * 2;
	}
	else
	if (self.spawnflags & SC_MINI)
	{
		setsize (self, VEC_HULL_MIN, '16 16 0');
		self.health = 150;
		self.max_health = 450;

		self.walkframe = $memstand1;
		self.rad_time = time + 50 + (random() * 10) + (sc_radt_mult * sc_count);
		if (random() < 0.5) self.rad_time = time + 20 + (random() * 10) + sc_count;
		self.lasttime = 0;

		self.noise = "scourge/idle2m.wav";
		self.noise1 = "scourge/sight2m.wav";
		self.noise2 = "scourge/walk2m.wav";
		self.noise3 = "scourge/pain1m.wav";
		self.noise4 = "scourge/pain2m.wav";
	}
	else
	if (self.spawnflags & SC_BABY)
	{
		setsize (self, '-8 -8 -24', ' 8 8 -8');
		self.health = 75;
		self.max_health = 450;

		self.walkframe = $bultstand1;
		self.rad_time = time + 40 + (random() * 10) + sc_count;
		if (random() < 0.5) self.rad_time = time + 10 + (random() * 10) + (sc_count / 2);
		self.lasttime = 0;

		self.noise = "scourge/null.wav"; // baby is pretty quiet - wants to survive
		self.noise1 = "scourge/null.wav";
		self.noise2 = "scourge/null.wav";
		self.noise3 = "scourge/pain1b.wav";
		self.noise4 = "scourge/pain2b.wav";
	}
	else
	{
		setsize (self, '-24 -24 -24', '24 24 24');
		self.health = 300;
		self.max_health = 450;

		if (enhance)
		if (random() < 0.8) self.rad_time = time + 40 + (random() * 20) + (sc_radt_mult * sc_count);
		if (ign != A_MONSTER) self.rad_time = self.rad_time * 2;
	}

	if (self.spawnflags & SC_CTHON)
	{
		self.skin = SKN_CTHON;
		self.health = floor(self.health * 1.333);
	}

	self.th_stand = scourge_stand1;
	self.th_walk = scourge_walk1;
	self.th_run = scourge_run1;
//   self.th_turn = scourge_turn1;
	self.th_pain = scourge_pain;
	self.th_die = scourge_die;
	self.th_melee = scourge_melee;

	self.yaw_speed = 60;
	self.attack_state = AS_DODGING;
	self.state = 0;

	walkmonster_start();
};
